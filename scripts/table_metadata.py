"""Contains utility functions to load metadata for tables generated by dsgrid queries."""

from enum import StrEnum
import json
from pathlib import Path
from typing import Literal, Self, Union

from pydantic import BaseModel, ConfigDict, Field
from typing_extensions import Annotated


class DimensionMetadata(BaseModel):
    """Defines the columns in a table for a dimension."""

    dimension_name: str
    column_names: list[str] = Field(
        description="Columns associated with this dimension. Could be a dimension query name, "
        "the string-ified DimensionType, multiple strings as can happen with time, or dimension "
        "record IDS if the dimension is pivoted."
    )


class DimensionsMetadata(BaseModel):
    """Records the dimensions and columns of a dataset as it is transformed by a query."""

    model_config = ConfigDict(
        protected_namespaces=(),
    )

    geography: list[DimensionMetadata] = []
    metric: list[DimensionMetadata] = []
    model_year: list[DimensionMetadata] = []
    scenario: list[DimensionMetadata] = []
    sector: list[DimensionMetadata] = []
    subsector: list[DimensionMetadata] = []
    time: list[DimensionMetadata] = []
    weather_year: list[DimensionMetadata] = []


class TableFormatType(StrEnum):
    """Defines the format of value columns in a dataset."""

    PIVOTED = "pivoted"
    UNPIVOTED = "unpivoted"


class PivotedTableFormat(BaseModel):
    format_type: Literal[TableFormatType.PIVOTED] = TableFormatType.PIVOTED
    pivoted_dimension_type: str = Field(
        description="The data dimension whose records are columns (pivoted) that contain "
        "data values (numeric) in the load_data table.",
    )


class UnpivotedTableFormat(BaseModel):
    format_type: Literal[TableFormatType.UNPIVOTED] = TableFormatType.UNPIVOTED


TableFormat = Annotated[
    Union[PivotedTableFormat, UnpivotedTableFormat],
    Field(
        description="Defines the format of the value columns of the result table.",
        discriminator="format_type",
        title="table_format",
    ),
]


class TableMetadata(BaseModel):
    """Defines the metadata for a table serialized to file."""

    dimensions: DimensionsMetadata
    table_format: TableFormat

    @classmethod
    def from_file(cls, filename: Path | str) -> Self:
        """Deserialize the model from a file."""
        path = filename if isinstance(filename, Path) else Path(filename)
        return cls(**json.loads(path.read_text(encoding="utf-8")))

    @classmethod
    def from_s3(cls, bucket: str, filepath: str) -> Self:
        """load json from s3"""
        from pyarrow import fs  # import here to keep pyarrow dependency only in this method

        s3 = fs.S3FileSystem(region=fs.resolve_s3_region("nrel-pds-dsgrid"))
        with s3.open_input_stream(f"{bucket}/{filepath}") as fs:
            return cls(**json.load(fs))

    def get_table_format_type(self) -> TableFormatType:
        """Return the format type of the table."""
        return TableFormatType(self.table_format.format_type)

    def list_columns(self, dimension_type: str) -> list[str]:
        """Return the columns in the table for the given dimension type."""
        if dimension_type not in self.dimensions.model_fields_set:
            fields = " ".join(DimensionsMetadata.model_fields)
            msg = f"{dimension_type=} is invalid. It must be one of these: {fields}"
            raise ValueError(msg)

        columns = []
        for dimension in getattr(self.dimensions, dimension_type):
            columns += dimension.column_names
        return columns


if __name__ == "__main__":
    import sys
    from rich import print

    if len(sys.argv) == 1:
        print(f"Usage: python {sys.argv[0]} METADATA_FILE", file=sys.stderr)
        sys.exit(1)

    filename = sys.argv[1]
    metadata = TableMetadata.from_file(filename)
    print(metadata)
    print("\nColumns by dimension type:")
    for field in type(metadata.dimensions).model_fields:
        print(f"{field}: ", metadata.list_columns(field))
